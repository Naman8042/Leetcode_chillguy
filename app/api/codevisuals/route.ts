// import axios from 'axios';
// import { NextResponse, NextRequest } from 'next/server';
// import { Buffer } from 'buffer';

// export async function POST(req: NextRequest) {
//   const { code, input } = await req.json();

//   try {
//     // Submit code with wait=true to avoid manual polling
//     const response = await axios.post(
//       'https://judge0-ce.p.rapidapi.com/submissions?base64_encoded=true&wait=true&fields=*',
//       {
//         source_code: Buffer.from(code).toString('base64'),
//         language_id: 54, // Language ID for C++
//         stdin: Buffer.from(input).toString('base64'),
//       },
//       {
//         headers: {
//           'x-rapidapi-key': 'b114da7e60msh383574889f4552fp174cc7jsnba0fd9875540',
//           'x-rapidapi-host': 'judge0-ce.p.rapidapi.com',
//         },
//       }
//     );

//     const result = response.data;

//     // Handle Judge0 status codes
//     if (result?.status?.id === 6) {
//       throw new Error(`Compilation Error: ${Buffer.from(result?.compile_output, 'base64').toString()}`);
//     }
//     if (result?.status?.id === 11) {
//       throw new Error(`Runtime Error: ${Buffer.from(result?.stderr, 'base64').toString()}`);
//     }
//     if (!result?.stdout) {
//       throw new Error('No output received from the code execution.');
//     }

//     const output = Buffer.from(result.stdout, 'base64').toString();
//     console.log(output)
//     // Simulated variable states and recursion tree (to be enhanced)
//     const variableStates = extractVariableStates(output);
//     const recursionTree = generateRecursionTree(output);

//     return NextResponse.json({
//       output,
//       variableStates,
//       recursionTree,
//     });
//   } catch (error: any) {
//     console.error('Execution Error:', error.message);
//     return NextResponse.json({
//       message: 'Error executing code',
//       error: error.message,
//       details: error.response?.data || null,
//     });
//   }
// }

// /**
//  * Simulate extraction of variable states from output.
//  * This is a placeholder and should be enhanced based on actual code analysis.
//  */
// function extractVariableStates(output: string): Record<string, any> {
//   const states: Record<string, any> = {};

//   // Extract variables and values from output using a regex (adjust this for your output format)
//   const regex = /(\w+)\s*=\s*([^\n]+)/g;
//   let match;
//   while ((match = regex.exec(output)) !== null) {
//     const [_, variable, value] = match;
//     states[variable] = value.trim();
//   }

//   return states;
// }


import axios from 'axios';
import { NextResponse, NextRequest } from 'next/server';

const GEMINI_API_KEY = 'AIzaSyAUguCatnzMGk_yC1P_Ks_uhEE6gHNsE14';




export async function POST(req: NextRequest) {
  const { code, input } = await req.json();

  try {
    const prompt = `
    
    Analyze the following code:

${code}

For the given input:

${input}

Provide a step-by-step dry run of the code execution if and only if code is correct if code has some mistake also return corrected code. The explanation should include:

1. The **current state** of variables or parameters at each significant step in the program.
2. The **decisions made** at each point, such as conditions checked, recursive calls made, or loops executed.
3. The **intermediate results** produced at each step, including return values or updates to variables.
4. The **final output** generated by the code.

Format the walkthrough like this:
- **Initial Input**: Describe the starting input.
- **Execution Steps**:
  - Step 1: Describe the first operation, the variables affected, and any changes made.
  - Step 2: Describe the next operation and its effect.
  - ...
- **Intermediate Results**: At each recursive or iterative step, show the intermediate results and how they build toward the final result.
- **Final Output**: Provide the final result.

The explanation should be detailed and easy to follow, suitable for debugging or understanding the logic of the code.

`;

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        contents: [{
          parts: [{ text: prompt }]
        }]
      }
    );

    const rawText = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!rawText) {
      throw new Error('Invalid response format from API');
    }

    // Parse execution trace - clean up markdown and formatting
    
    

    // Create textual tree representation
    

    return NextResponse.json({
      success: true,
      data: {
        // executionTrace,
        // textualTree,
        // recursionTree: jsonTree
        rawText
      }
    });

  } catch (error: any) {
    console.error('Error:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      details: error.response?.data
    }, { status: 500 });
  }
}

